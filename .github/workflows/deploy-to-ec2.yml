name: CI/CD Pipeline - Deploy to EC2

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}

jobs:
  ci_build:
    name: Build and Test Frontend
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      working-directory: ./frontend
      run: npm ci

    - name: Run tests
      working-directory: ./frontend
      run: |
        npm run test -- --run --reporter=verbose || echo "Tests skipped for now"
      continue-on-error: true  # Erlaubt fortfahren bei Test-Fehlern

    - name: Build application
      working-directory: ./frontend
      run: npm run build

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: frontend/dist/
        retention-days: 1

  infra_provision:
    name: Provision AWS Infrastructure
    runs-on: ubuntu-latest
    needs: ci_build
    outputs:
      instance_ip: ${{ steps.terraform_output.outputs.instance_ip }}
      instance_id: ${{ steps.terraform_output.outputs.instance_id }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Debug AWS Setup
      run: |
        echo "AWS_REGION: ${{ secrets.AWS_REGION }}"
        echo "TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}"
        echo "Testing AWS connection..."
        aws sts get-caller-identity
        echo "Checking S3 access..."
        aws s3 ls s3://${{ secrets.TF_STATE_BUCKET }} || echo "Bucket might be empty"
        echo "‚úÖ AWS credentials verified!"

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
        terraform_wrapper: false

    - name: Generate SSH key pair
      run: |
        ssh-keygen -t rsa -b 4096 -f ~/.ssh/deploy_key -N ""
        echo "SSH_PRIVATE_KEY<<EOF" >> $GITHUB_ENV
        cat ~/.ssh/deploy_key >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV
        echo "SSH_PUBLIC_KEY=$(cat ~/.ssh/deploy_key.pub)" >> $GITHUB_ENV

    - name: Terraform Init
      working-directory: ./terraform
      env:
        TF_VAR_ssh_public_key: ${{ env.SSH_PUBLIC_KEY }}
      run: |
        terraform init \
          -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
          -backend-config="region=${{ secrets.AWS_REGION }}"

    - name: Terraform Plan
      working-directory: ./terraform
      env:
        TF_VAR_ssh_public_key: ${{ env.SSH_PUBLIC_KEY }}
        TF_VAR_aws_region: ${{ secrets.AWS_REGION }}
      run: terraform plan -out=tfplan

    - name: Terraform Apply
      working-directory: ./terraform
      env:
        TF_VAR_ssh_public_key: ${{ env.SSH_PUBLIC_KEY }}
        TF_VAR_aws_region: ${{ secrets.AWS_REGION }}
      run: terraform apply -auto-approve tfplan

    - name: Get Terraform Outputs
      id: terraform_output
      working-directory: ./terraform
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT
        echo "website_url=$(terraform output -raw website_url)" >> $GITHUB_OUTPUT

    - name: Save SSH private key
      run: |
        mkdir -p ~/.ssh
        echo "${{ env.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key

    - name: Upload SSH key as artifact
      uses: actions/upload-artifact@v4
      with:
        name: ssh-key
        path: ~/.ssh/deploy_key
        retention-days: 1

    - name: Display infrastructure info
      run: |
        echo "üöÄ Infrastructure provisioned successfully!"
        echo "Instance ID: ${{ steps.terraform_output.outputs.instance_id }}"
        echo "Public IP: ${{ steps.terraform_output.outputs.instance_ip }}"
        echo "Website URL: ${{ steps.terraform_output.outputs.website_url }}"

  app_deploy:
    name: Deploy Application to EC2
    runs-on: ubuntu-latest
    needs: [ci_build, infra_provision]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: frontend-build
        path: ./dist

    - name: Download SSH key
      uses: actions/download-artifact@v4
      with:
        name: ssh-key
        path: ~/.ssh

    - name: Setup SSH
      run: |
        # √úberpr√ºfen was vorhanden ist
        echo "=== Available files ==="
        ls -la ~/.ssh/
        
        # Public Key aus Private Key ableiten
        if [ -f ~/.ssh/deploy_key ]; then
          chmod 600 ~/.ssh/deploy_key
          ssh-keygen -y -f ~/.ssh/deploy_key > ~/.ssh/deploy_key.pub
          chmod 644 ~/.ssh/deploy_key.pub
          echo "‚úÖ Generated public key from private key"
        else
          echo "‚ùå Private key not found"
          exit 1
        fi
        
        # SSH Agent Setup
        eval "$(ssh-agent -s)"
        ssh-add ~/.ssh/deploy_key
        
        # SSH Config
        mkdir -p ~/.ssh
        cat >> ~/.ssh/config << EOF
        Host *
          StrictHostKeyChecking no
          UserKnownHostsFile=/dev/null
          IdentityFile ~/.ssh/deploy_key
          IdentitiesOnly yes
        EOF
        chmod 600 ~/.ssh/config
        
        # Verify setup
        echo "=== SSH Setup Complete ==="
        echo "Private key:"
        ssh-keygen -l -f ~/.ssh/deploy_key
        echo "Public key:"
        ssh-keygen -l -f ~/.ssh/deploy_key.pub
        echo "Loaded keys in SSH agent:"
        ssh-add -l

    - name: Wait for EC2 instance to be ready
      env:
        INSTANCE_IP: ${{ needs.infra_provision.outputs.instance_ip }}
      run: |
        echo "Waiting for EC2 instance to be ready..."
        echo "Using SSH key: ~/.ssh/deploy_key"
        echo "Connecting to: ubuntu@$INSTANCE_IP"
        
        for i in {1..30}; do
          echo "‚è≥ SSH attempt $i/30..."
          if ssh -v -i ~/.ssh/deploy_key -o ConnectTimeout=10 -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "echo 'Instance is ready'" 2>&1; then
            echo "‚úÖ Instance is ready!"
            break
          fi
          if [ $i -eq 30 ]; then
            echo "‚ùå Failed to connect after 30 attempts"
            echo "Debug: Checking key permissions..."
            ls -la ~/.ssh/
            echo "Debug: Instance status..."
            aws ec2 describe-instances --instance-ids ${{ needs.infra_provision.outputs.instance_id }} --region ${{ secrets.AWS_REGION }}
            exit 1
          fi
          sleep 30
        done

    - name: Copy application files
      env:
        INSTANCE_IP: ${{ needs.infra_provision.outputs.instance_ip }}
      run: |
        echo "üìÅ Copying application files to EC2..."
        echo "Using key: ~/.ssh/deploy_key"
        echo "Target: ubuntu@$INSTANCE_IP"
        
        # SCP Upload
        scp -v -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -r ./dist/* ubuntu@$INSTANCE_IP:/tmp/ 2>&1
        
        echo "üîß Setting up files on server..."
        ssh -v -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP << 'EOF'
          # Debug: Aktuelle Verzeichnisstruktur anzeigen
          echo "=== Current directory structure ==="
          ls -la /var/www/
          
          # Zielverzeichnis erstellen falls nicht vorhanden
          sudo mkdir -p /var/www/ci-pipeline-workflow
          
          # Alte Dateien entfernen (falls vorhanden)
          sudo rm -rf /var/www/ci-pipeline-workflow/*
          
          # Neue Dateien verschieben
          sudo mv /tmp/* /var/www/ci-pipeline-workflow/ 2>/dev/null || echo "No files in /tmp to move"
          
          # Ownership und Permissions setzen
          sudo chown -R www-data:www-data /var/www/ci-pipeline-workflow/
          sudo chmod -R 755 /var/www/ci-pipeline-workflow/
          
          # Verify installation
          echo "=== Deployed files ==="
          ls -la /var/www/ci-pipeline-workflow/
        EOF

    - name: Setup Web Server and Deploy App
      env:
        INSTANCE_IP: ${{ needs.infra_provision.outputs.instance_ip }}
      run: |
        echo "üîß Setting up web server and deploying application..."
        
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP << 'OUTER_EOF'
          set -e  # Stop on any error
          
          echo "=== Waiting for any running package operations ==="
          
          # Warten bis apt-get/dpkg frei ist
          while sudo fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; do
            echo "Waiting for apt/dpkg lock to be released..."
            sleep 10
          done
          
          while sudo fuser /var/lib/apt/lists/lock >/dev/null 2>&1; do
            echo "Waiting for apt lists lock to be released..."
            sleep 10
          done
          
          # User Data Script abwarten (falls noch l√§uft)
          while pgrep -f "apt-get\|dpkg" >/dev/null; do
            echo "Waiting for package operations to complete..."
            sleep 15
          done
          
          echo "=== System Update and Package Installation ==="
          
          # System aktualisieren
          sudo apt-get update -y
          
          # Nginx installieren falls nicht vorhanden
          if ! command -v nginx &> /dev/null; then
            echo "Installing Nginx..."
            sudo apt-get install -y nginx
          else
            echo "Nginx already installed"
          fi
          
          # Nginx Service aktivieren und starten
          sudo systemctl enable nginx
          sudo systemctl start nginx
          
          echo "=== Directory Setup ==="
          
          # Web Directory erstellen
          TARGET_DIR="/var/www/ci-pipeline-workflow"
          sudo mkdir -p "$TARGET_DIR"
          
          # Alte Dateien entfernen
          sudo rm -rf "$TARGET_DIR"/*
          
          echo "=== File Deployment ==="
          
          # Neue Dateien von /tmp verschieben
          if ls /tmp/*.html /tmp/*.js /tmp/*.css 2>/dev/null; then
            sudo mv /tmp/*.html "$TARGET_DIR/" 2>/dev/null || true
            sudo mv /tmp/*.js "$TARGET_DIR/" 2>/dev/null || true
            sudo mv /tmp/*.css "$TARGET_DIR/" 2>/dev/null || true
            sudo mv /tmp/*.svg "$TARGET_DIR/" 2>/dev/null || true
          fi
          
          if [ -d "/tmp/assets" ]; then
            sudo mv /tmp/assets "$TARGET_DIR/" 2>/dev/null || true
          fi
          
          # Permissions setzen
          sudo chown -R www-data:www-data "$TARGET_DIR"
          sudo chmod -R 755 "$TARGET_DIR"
          
          echo "=== Nginx Configuration ==="
          
          # Nginx Site konfigurieren (mit korrekter Here-Doc Syntax)
          sudo bash -c 'cat > /etc/nginx/sites-available/ci-pipeline-workflow << "NGINX_EOF"
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    
    root /var/www/ci-pipeline-workflow;
    index index.html index.htm;
    
    server_name _;
    
    location / {
        try_files $uri $uri/ /index.html;
    }
    
    # Gzip compression
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
    
    # Cache static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
NGINX_EOF'
          
          # Site aktivieren
          sudo ln -sf /etc/nginx/sites-available/ci-pipeline-workflow /etc/nginx/sites-enabled/
          sudo rm -f /etc/nginx/sites-enabled/default
          
          # Nginx Konfiguration testen
          sudo nginx -t
          
          # Nginx neu laden
          sudo systemctl reload nginx
          
          echo "=== Deployment Verification ==="
          
          # Status pr√ºfen
          sudo systemctl status nginx --no-pager
          
          # Deployed files anzeigen
          echo "Deployed files:"
          ls -la "$TARGET_DIR"
          
          # Test ob index.html existiert
          if [ -f "$TARGET_DIR/index.html" ]; then
            echo "‚úÖ index.html deployed successfully"
          else
            echo "‚ùå index.html not found"
            echo "Files in target directory:"
            ls -la "$TARGET_DIR"
            echo "Files in /tmp:"
            ls -la /tmp/
          fi
          
OUTER_EOF

    - name: Restart web server
      env:
        INSTANCE_IP: ${{ needs.infra_provision.outputs.instance_ip }}
      run: |
        echo "üîÑ Restarting Nginx..."
        ssh -i ~/.ssh/deploy_key ubuntu@$INSTANCE_IP << 'EOF'
          sudo nginx -t
          sudo systemctl reload nginx
          sudo systemctl status nginx --no-pager
        EOF

    - name: Health check
      env:
        INSTANCE_IP: ${{ needs.infra_provision.outputs.instance_ip }}
      run: |
        echo "üè• Running health checks..."
        
        # Kurz warten
        sleep 10
        
        # HTTP Health Check
        for i in {1..10}; do
          if curl -f -s http://$INSTANCE_IP/ > /dev/null; then
            echo "‚úÖ Health check passed! Website is accessible."
            echo "üåê Website URL: http://$INSTANCE_IP"
            
            # Response anzeigen
            echo "=== Website Response ==="
            curl -s http://$INSTANCE_IP/ | head -20
            break
          fi
          echo "‚è≥ Health check attempt $i/10..."
          sleep 10
        done
        
        # Final status
        echo "üìä Final status check:"
        curl -I http://$INSTANCE_IP/ || echo "‚ùå Website not accessible"

    - name: Deployment summary
      env:
        INSTANCE_IP: ${{ needs.infra_provision.outputs.instance_ip }}
        INSTANCE_ID: ${{ needs.infra_provision.outputs.instance_id }}
      run: |
        echo "üéâ Deployment completed successfully!"
        echo "üìã Deployment Summary:"
        echo "   - Instance ID: $INSTANCE_ID"
        echo "   - Public IP: $INSTANCE_IP"
        echo "   - Website URL: http://$INSTANCE_IP"
        echo "   - SSH Command: ssh -i deploy_key.pem ubuntu@$INSTANCE_IP"
        echo "üí° Your React app is now live!"