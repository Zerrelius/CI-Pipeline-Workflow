name: CI/CD Pipeline - Deploy to EC2

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}

jobs:
  ci_build:
    name: Build and Test Frontend
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      working-directory: ./frontend
      run: npm ci

    - name: Run tests
      working-directory: ./frontend
      run: |
        npm run test -- --run --reporter=verbose || echo "Tests skipped for now"
      continue-on-error: true  # Erlaubt fortfahren bei Test-Fehlern

    - name: Build application
      working-directory: ./frontend
      run: npm run build

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: frontend-build
        path: frontend/dist/
        retention-days: 1

  infra_provision:
    name: Provision AWS Infrastructure
    runs-on: ubuntu-latest
    needs: ci_build
    outputs:
      instance_ip: ${{ steps.terraform_output.outputs.instance_ip }}
      instance_id: ${{ steps.terraform_output.outputs.instance_id }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Debug AWS Setup
      run: |
        echo "AWS_REGION: ${{ secrets.AWS_REGION }}"
        echo "TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}"
        echo "Testing AWS connection..."
        aws sts get-caller-identity
        echo "Checking S3 access..."
        aws s3 ls s3://${{ secrets.TF_STATE_BUCKET }} || echo "Bucket might be empty"
        echo "‚úÖ AWS credentials verified!"

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
        terraform_wrapper: false

    - name: Generate SSH key pair
      run: |
        ssh-keygen -t rsa -b 4096 -f ~/.ssh/deploy_key -N ""
        echo "SSH_PRIVATE_KEY<<EOF" >> $GITHUB_ENV
        cat ~/.ssh/deploy_key >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV
        echo "SSH_PUBLIC_KEY=$(cat ~/.ssh/deploy_key.pub)" >> $GITHUB_ENV

    - name: Terraform Init
      working-directory: ./terraform
      env:
        TF_VAR_ssh_public_key: ${{ env.SSH_PUBLIC_KEY }}
      run: |
        terraform init \
          -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
          -backend-config="region=${{ secrets.AWS_REGION }}"

    - name: Terraform Plan
      working-directory: ./terraform
      env:
        TF_VAR_ssh_public_key: ${{ env.SSH_PUBLIC_KEY }}
        TF_VAR_aws_region: ${{ secrets.AWS_REGION }}
      run: terraform plan -out=tfplan

    - name: Terraform Apply
      working-directory: ./terraform
      env:
        TF_VAR_ssh_public_key: ${{ env.SSH_PUBLIC_KEY }}
        TF_VAR_aws_region: ${{ secrets.AWS_REGION }}
      run: terraform apply -auto-approve tfplan

    - name: Get Terraform Outputs
      id: terraform_output
      working-directory: ./terraform
      run: |
        echo "instance_ip=$(terraform output -raw instance_public_ip)" >> $GITHUB_OUTPUT
        echo "instance_id=$(terraform output -raw instance_id)" >> $GITHUB_OUTPUT
        echo "website_url=$(terraform output -raw website_url)" >> $GITHUB_OUTPUT

    - name: Save SSH private key
      run: |
        mkdir -p ~/.ssh
        echo "${{ env.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key

    - name: Upload SSH key as artifact
      uses: actions/upload-artifact@v4
      with:
        name: ssh-key
        path: ~/.ssh/deploy_key
        retention-days: 1

    - name: Display infrastructure info
      run: |
        echo "üöÄ Infrastructure provisioned successfully!"
        echo "Instance ID: ${{ steps.terraform_output.outputs.instance_id }}"
        echo "Public IP: ${{ steps.terraform_output.outputs.instance_ip }}"
        echo "Website URL: ${{ steps.terraform_output.outputs.website_url }}"

  app_deploy:
    name: Deploy Application to EC2
    runs-on: ubuntu-latest
    needs: [ci_build, infra_provision]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: frontend-build
        path: ./dist

    - name: Download SSH key
      uses: actions/download-artifact@v4
      with:
        name: ssh-key
        path: ~/.ssh

    - name: Setup SSH
      run: |
        # √úberpr√ºfen was vorhanden ist
        echo "=== Available files ==="
        ls -la ~/.ssh/
        
        # Public Key aus Private Key ableiten
        if [ -f ~/.ssh/deploy_key ]; then
          chmod 600 ~/.ssh/deploy_key
          ssh-keygen -y -f ~/.ssh/deploy_key > ~/.ssh/deploy_key.pub
          chmod 644 ~/.ssh/deploy_key.pub
          echo "‚úÖ Generated public key from private key"
        else
          echo "‚ùå Private key not found"
          exit 1
        fi
        
        # SSH Agent Setup
        eval "$(ssh-agent -s)"
        ssh-add ~/.ssh/deploy_key
        
        # SSH Config
        mkdir -p ~/.ssh
        cat >> ~/.ssh/config << EOF
        Host *
          StrictHostKeyChecking no
          UserKnownHostsFile=/dev/null
          IdentityFile ~/.ssh/deploy_key
          IdentitiesOnly yes
        EOF
        chmod 600 ~/.ssh/config
        
        # Verify setup
        echo "=== SSH Setup Complete ==="
        echo "Private key:"
        ssh-keygen -l -f ~/.ssh/deploy_key
        echo "Public key:"
        ssh-keygen -l -f ~/.ssh/deploy_key.pub
        echo "Loaded keys in SSH agent:"
        ssh-add -l

    - name: Wait for EC2 instance to be ready
      env:
        INSTANCE_IP: ${{ needs.infra_provision.outputs.instance_ip }}
      run: |
        echo "Waiting for EC2 instance to be ready..."
        echo "Using SSH key: ~/.ssh/deploy_key"
        echo "Connecting to: ubuntu@$INSTANCE_IP"
        
        for i in {1..30}; do
          echo "‚è≥ SSH attempt $i/30..."
          if ssh -v -i ~/.ssh/deploy_key -o ConnectTimeout=10 -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "echo 'Instance is ready'" 2>&1; then
            echo "‚úÖ Instance is ready!"
            break
          fi
          if [ $i -eq 30 ]; then
            echo "‚ùå Failed to connect after 30 attempts"
            echo "Debug: Checking key permissions..."
            ls -la ~/.ssh/
            echo "Debug: Instance status..."
            aws ec2 describe-instances --instance-ids ${{ needs.infra_provision.outputs.instance_id }} --region ${{ secrets.AWS_REGION }}
            exit 1
          fi
          sleep 30
        done

    - name: Copy application files
      env:
        INSTANCE_IP: ${{ needs.infra_provision.outputs.instance_ip }}
      run: |
        echo "üìÅ Copying application files to EC2..."
        echo "Using key: ~/.ssh/deploy_key"
        echo "Target: ubuntu@$INSTANCE_IP"
        
        # SCP Upload
        scp -v -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -r ./dist/* ubuntu@$INSTANCE_IP:/tmp/ 2>&1
        
        echo "üîß Setting up files on server..."
        ssh -v -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP << 'EOF'
          # Debug: Aktuelle Verzeichnisstruktur anzeigen
          echo "=== Current directory structure ==="
          ls -la /var/www/
          
          # Zielverzeichnis erstellen falls nicht vorhanden
          sudo mkdir -p /var/www/ci-pipeline-workflow
          
          # Alte Dateien entfernen (falls vorhanden)
          sudo rm -rf /var/www/ci-pipeline-workflow/*
          
          # Neue Dateien verschieben
          sudo mv /tmp/* /var/www/ci-pipeline-workflow/ 2>/dev/null || echo "No files in /tmp to move"
          
          # Ownership und Permissions setzen
          sudo chown -R www-data:www-data /var/www/ci-pipeline-workflow/
          sudo chmod -R 755 /var/www/ci-pipeline-workflow/
          
          # Verify installation
          echo "=== Deployed files ==="
          ls -la /var/www/ci-pipeline-workflow/
        EOF

    - name: Setup Web Server and Deploy App
      env:
        INSTANCE_IP: ${{ needs.infra_provision.outputs.instance_ip }}
      run: |
        echo "üîß Setting up web server and deploying application..."
        
        # Deployment Script erstellen
        cat > deploy_script.sh << 'DEPLOY_SCRIPT'
        #!/bin/bash
        set -e

        echo "=== Waiting for all package operations to complete ==="

        # Funktion f√ºr robustes Warten
        wait_for_apt_lock() {
            local max_wait=600  # 10 Minuten maximum
            local waited=0
            
            while [ $waited -lt $max_wait ]; do
                # Pr√ºfe alle m√∂glichen Locks
                if ! sudo fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 && \
                   ! sudo fuser /var/lib/apt/lists/lock >/dev/null 2>&1 && \
                   ! sudo fuser /var/lib/dpkg/lock >/dev/null 2>&1 && \
                   ! pgrep -f "apt-get|dpkg|unattended-upgrade" >/dev/null; then
                    echo "‚úÖ All package operations completed"
                    return 0
                fi
                
                echo "‚è≥ Waiting for package operations... (${waited}s/${max_wait}s)"
                sleep 15
                waited=$((waited + 15))
            done
            
            echo "‚ùå Timeout waiting for package operations"
            return 1
        }

        # Warten auf APT Lock
        wait_for_apt_lock

        # Zus√§tzliche Sicherheit: Cloud-init Status pr√ºfen
        echo "=== Checking cloud-init status ==="
        if command -v cloud-init >/dev/null; then
            sudo cloud-init status --wait || echo "Cloud-init wait failed, continuing..."
        fi

        echo "=== Package Installation ==="
        # APT mit Retry-Logik
        install_with_retry() {
            local package=$1
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
                echo "Installing $package (attempt $attempt/$max_attempts)"
                if sudo DEBIAN_FRONTEND=noninteractive apt-get install -y $package; then
                    echo "‚úÖ $package installed successfully"
                    return 0
                else
                    echo "‚ùå Failed to install $package (attempt $attempt)"
                    if [ $attempt -lt $max_attempts ]; then
                        echo "Waiting before retry..."
                        sleep 30
                        # APT Cache bereinigen
                        sudo apt-get clean
                        sudo apt-get update
                    fi
                    attempt=$((attempt + 1))
                fi
            done
            
            echo "‚ùå Failed to install $package after $max_attempts attempts"
            return 1
        }

        # System Update
        sudo apt-get update -y

        # Nginx installieren falls nicht vorhanden
        if ! command -v nginx &> /dev/null; then
            install_with_retry nginx
        else
            echo "‚úÖ Nginx already installed"
        fi

        echo "=== Nginx Service Setup ==="
        sudo systemctl enable nginx
        sudo systemctl start nginx || sudo systemctl restart nginx

        echo "=== Application Deployment ==="
        TARGET_DIR="/var/www/ci-pipeline-workflow"
        sudo mkdir -p "$TARGET_DIR"
        sudo rm -rf "$TARGET_DIR"/*

        # Files deployen
        echo "Deploying files from /tmp..."
        file_count=0

        # HTML files
        for file in /tmp/*.html; do
            if [ -f "$file" ]; then
                sudo mv "$file" "$TARGET_DIR/"
                file_count=$((file_count + 1))
            fi
        done

        # JS files
        for file in /tmp/*.js; do
            if [ -f "$file" ]; then
                sudo mv "$file" "$TARGET_DIR/"
                file_count=$((file_count + 1))
            fi
        done

        # CSS files
        for file in /tmp/*.css; do
            if [ -f "$file" ]; then
                sudo mv "$file" "$TARGET_DIR/"
                file_count=$((file_count + 1))
            fi
        done

        # SVG files
        for file in /tmp/*.svg; do
            if [ -f "$file" ]; then
                sudo mv "$file" "$TARGET_DIR/"
                file_count=$((file_count + 1))
            fi
        done

        # Assets directory
        if [ -d "/tmp/assets" ]; then
            sudo mv /tmp/assets "$TARGET_DIR/"
            file_count=$((file_count + 1))
        fi

        echo "Deployed $file_count files/directories"

        # Permissions
        sudo chown -R www-data:www-data "$TARGET_DIR"
        sudo chmod -R 755 "$TARGET_DIR"

        echo "=== Nginx Configuration ==="
        # Nginx Config erstellen
        sudo tee /etc/nginx/sites-available/default > /dev/null << 'NGINX_CONFIG'
        server {
            listen 80 default_server;
            listen [::]:80 default_server;
            
            root /var/www/ci-pipeline-workflow;
            index index.html;
            
            server_name _;
            
            location / {
                try_files $uri $uri/ /index.html;
            }
            
            gzip on;
            gzip_types text/plain text/css application/json application/javascript;
        }
        NGINX_CONFIG

        # Nginx testen und neustarten
        sudo nginx -t
        sudo systemctl reload nginx

        echo "=== Final Verification ==="
        sudo systemctl status nginx --no-pager
        echo "Files in target directory:"
        ls -la "$TARGET_DIR"

        if [ -f "$TARGET_DIR/index.html" ]; then
            echo "‚úÖ Deployment successful - index.html found"
        else
            echo "‚ùå Deployment issue - index.html not found"
            echo "Files in /tmp:"
            ls -la /tmp/
        fi

        echo "‚úÖ Setup completed"
        DEPLOY_SCRIPT

        # Script ausf√ºhrbar machen und √ºbertragen
        chmod +x deploy_script.sh
        
        echo "üì§ Uploading deployment script..."
        scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no deploy_script.sh ubuntu@$INSTANCE_IP:/tmp/
        
        echo "üöÄ Executing deployment script..."
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ubuntu@$INSTANCE_IP "bash /tmp/deploy_script.sh"

    - name: Restart web server
      env:
        INSTANCE_IP: ${{ needs.infra_provision.outputs.instance_ip }}
      run: |
        echo "üîÑ Restarting Nginx..."
        ssh -i ~/.ssh/deploy_key ubuntu@$INSTANCE_IP << 'EOF'
          sudo nginx -t
          sudo systemctl reload nginx
          sudo systemctl status nginx --no-pager
        EOF

    - name: Health check
      env:
        INSTANCE_IP: ${{ needs.infra_provision.outputs.instance_ip }}
      run: |
        echo "üè• Running health checks..."
        
        # Kurz warten
        sleep 10
        
        # HTTP Health Check
        for i in {1..10}; do
          if curl -f -s http://$INSTANCE_IP/ > /dev/null; then
            echo "‚úÖ Health check passed! Website is accessible."
            echo "üåê Website URL: http://$INSTANCE_IP"
            
            # Response anzeigen
            echo "=== Website Response ==="
            curl -s http://$INSTANCE_IP/ | head -20
            break
          fi
          echo "‚è≥ Health check attempt $i/10..."
          sleep 10
        done
        
        # Final status
        echo "üìä Final status check:"
        curl -I http://$INSTANCE_IP/ || echo "‚ùå Website not accessible"

    - name: Deployment summary
      env:
        INSTANCE_IP: ${{ needs.infra_provision.outputs.instance_ip }}
        INSTANCE_ID: ${{ needs.infra_provision.outputs.instance_id }}
      run: |
        echo "üéâ Deployment completed successfully!"
        echo "üìã Deployment Summary:"
        echo "   - Instance ID: $INSTANCE_ID"
        echo "   - Public IP: $INSTANCE_IP"
        echo "   - Website URL: http://$INSTANCE_IP"
        echo "   - SSH Command: ssh -i deploy_key.pem ubuntu@$INSTANCE_IP"
        echo "üí° Your React app is now live!"